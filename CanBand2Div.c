/*******************************************************************************

			                   CAN总线消息结构-相关函数实现
//提供 CAN2.0版支持,使用此文件请使用函数接口
*******************************************************************************/
#include "CanMsg.h"    

/*******************************************************************************
			                       相关函数接口实现
*******************************************************************************/

//--------------------------- CAN硬件得到波特率查找表函数----------------------------
static const unsigned long _CanBitTimeLUT[] = {
  /* [ 8] */  0x00002211, /*  0 | 2+1 |   2+1  |   1+1  |   1+1  |  8  | 75% */
  /* [ 9] */  0x00001122, /*  0 | 1+1 |   1+1  |   2+1  |   2+1  |  9  | 67% */
  /* [10] */  0x00002222, /*  0 | 2+1 |   2+1  |   2+1  |   2+1  | 10  | 70% */
  /* [11] */  0x00003322, /*  0 | 3+1 |   3+1  |   2+1  |   2+1  | 11  | 72% */
  /* [12] */  0x00002233, /*  0 | 2+1 |   2+1  |   3+1  |   3+1  | 12  | 67% */
  /* [13] */  0x00003333, /*  0 | 3+1 |   3+1  |   3+1  |   3+1  | 13  | 77% */
  /* [14] */  0x00003334, /*  0 | 3+1 |   3+1  |   3+1  |   4+1  | 14  | 64% */
  /* [15] */  0x00003344, /*  0 | 3+1 |   3+1  |   4+1  |   4+1  | 15  | 67% */
  /* [16] */  0x00003444, /*  0 | 3+1 |   4+1  |   4+1  |   4+1  | 16  | 69% */
  /* [17] */  0x00003544, /*  0 | 3+1 |   5+1  |   4+1  |   4+1  | 17  | 71% */
  /* [18] */  0x00003455, /*  0 | 3+1 |   4+1  |   5+1  |   5+1  | 18  | 67% */
  /* [19] */  0x00003555, /*  0 | 3+1 |   5+1  |   5+1  |   5+1  | 19  | 68% */
  /* [20] */  0x00003655, /*  0 | 3+1 |   6+1  |   5+1  |   5+1  | 20  | 70% */
  /* [21] */  0x00003755, /*  0 | 3+1 |   7+1  |   5+1  |   5+1  | 21  | 71% */
  /* [22] */  0x00003766, /*  0 | 3+1 |   7+1  |   6+1  |   6+1  | 22  | 68% */
  /* [23] */  0x00003776, /*  0 | 3+1 |   7+1  |   7+1  |   6+1  | 23  | 70% */
  /* [24] */  0x00003677, /*  0 | 3+1 |   6+1  |   7+1  |   7+1  | 24  | 67% */
  /* [25] */  0x00003777, /*  0 | 3+1 |   7+1  |   7+1  |   7+1  | 25  | 68% */
};

//--------------------------- CAN硬件得到波特率函数----------------------------
//返回值定义为:
//0-3bit: Phase2, 即相位缓冲段2, 1~7
//4-7bit: Phase1, 即相位缓冲段1, 1~7, 注：有的CAN控制器相位缓冲区是合二为一的
//8-11bit: Prop,  即传播段,1~7
//12-15bit: Sjw,  即再同步跳转宽度， 1~3
//16-22bit: div:  即预分频数, 0~(最小分频数 - 1)
//CAN总线每个Bit时钟由: (1同步段+传播段+相位缓冲段1+相位缓冲段2构成)
//波特率 = CanMck / ((Phase2 + Phase1 + Prop + 1) * div)
//形参pBaudrate送入当前波特率,返回匹配后的波特率,-1表示<最小分频数分频分不过来了
unsigned long CanBand2Div_Get(unsigned long CanMck,    //CAN时钟
                              unsigned char  MixDiv,    //最小分频数
                              unsigned long *pBaudrate)
{
  //此实现自DAP2010移值：
  unsigned long Baudrate = *pBaudrate;
  //达到最小波特率了(分频分不过来了)
  if(((CanMck + (Baudrate * 25 - 1)) / (Baudrate * 25)) > MixDiv)
    return (unsigned long)-1;
  
  unsigned long Mod = 0xffffffff; //预分频器余数,最接近值，为0时表示正好匹配波特率
  
  unsigned char TQ = 8; //置最小TQ值，这样匹配波特率的误差越小
  for(unsigned char i = 8; i <= 25; i++){
    if((CanMck / (Baudrate * i)) <= MixDiv){//够分频时
      unsigned long CurMod = CanMck % (Baudrate * i);
      if(CurMod < Mod){
        Mod = CurMod;
        TQ = i;
        if(!Mod) break;    //100%匹配设定波特率
      }
    }
  }
  unsigned long PreScale = CanMck / (Baudrate * TQ);
  *pBaudrate = CanMck / (PreScale * TQ);//返回实际的波特率
  return ((PreScale - 1) << 16) | _CanBitTimeLUT[TQ - 8];
}















